int main(void){
  init();
  Serial.begin(9600);

  //Konfiguration
  //TIMER1
  //da wir für den PWM-Analyzer keinen PWM-Ausgang brauchen - wir messen ja nur. Der Timer1 läuft dafür im Normalmodus
  TCCR1A = 0;
  TCCR1B = (1 << ICES1) | (1 << CS11) | (1 << CS10);

  //Interrupt
  TIMSK1 = (1 << ICIE1);

  sei();

  while(1){
    noInterrupts();
    uint32_t rise1 = t_rise1;
    uint32_t rise2 = t_rise2;
    uint32_t fall = t_fall;
    interrupts();
    //noInterrupts() : sozusagen Interrupts kurz ausschalten bis Interrupts() wieder aktiviert, damit die Variablen stabil bleiben und es kein neuer Messwert während der Berechnung "reinschreiben" kann
    //Interrupt() : Interrupt wieder aktiv, die Hardware darf jetzt wieder neue Flanke erfassen

    uint32_t High_time = fall - rise1;
    uint32_t Periode = rise2 - rise1;

    if(Periode > 0){
      float T_tick = 64.0/16000000.0;
      float frequenz = 1/(Periode * T_tick);
      float Tastgrad = (High_time / Periode) * 100;

      Serial.print("Frequenz: ");
      Serial.print(frequenz);
      Serial.println(" Hz");

      Serial.print("Tastgrad: ");
      Serial.print(Tastgrad);
      Serial.println(" %");

      _delay_ms(2000);
    }
  }
}

ISR(Timer1_CAPT_vect){
  static uint8_t step = 0;

  if(step == 0){
    // 1.Rising Edge erkannt
    t_rise1 = ICR1;
    TCCR1B &= ~(1 << ICES1);        //auf Falling Edge umschalten
    step = 1;
  }
  if(step == 1){
    // Falling Edge erkannt
    t_fall = ICR1;
    High_time = t_fall - t_rise1;
    TCCR1B |= (1 << ICES1);         //zurück auf Rising Edge umschalten
    step = 2;
  }
  if(step == 2){
    // 2.Rising Edge erkannt
    t_rise2 = ICR1;
    TCCR1B &= ~(1 << ICES1);        //auf Falling Edge umschalten
    Periode = t_rise2 - t_rise1;
    step = 0;
  }
}
